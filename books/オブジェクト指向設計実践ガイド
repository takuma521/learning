# 1. オブジェクト指向設計

この本の主題はオブジェクト指向ソフトウェアの設計。

オブジェクト指向設計の手法を学ぶにはオブジェクトの世界へ没入すること。
オブジェクト指向の視点を手に入れればよい。

この章では、
オブジェクト指向せっけについての一般的な議論を述べ設計の下敷きとなる議論ができたら、
その後に設計をいつ行うかとその良し悪しをどのように判断するかを説明する。
最後にオブジェクト指向設計の概要を説明する。

## 1.1 設計の賞賛
ソフトウェアは目的があって作られる。
楽しさと生産性は重なる
オブジェクト指向設計の手法に従えば費用効果の高いソフトウェアを産み出し、楽しく取り組めるコードで実現できる。

アプリケーションには変更が訪れるもの。
変更の必要性こそが設計を重要にする。
変更が容易なものは拡張するにも楽しい。変更を拒むものは逆。

オブジェクト指向のアプリケーションは部品から構成され、相互に作用しあい全体の振る舞いが生まれる。
部品はオブジェクト。
相互作用がメッセージで送り手が受けてのことを知る必要がある。この知識が２つのオブジェクト間に依存間液を作り出す。
この依存関係が変更を邪魔する。
オブジェクト指向設計とは依存関係を管理すること。
設計がないと管理されていない依存関係が大混乱を引き起こす。
オブジェクト１つを変更すると一緒に動くオブジェクトにも変更を加えることになる。
アプリが小さければ設計が貧弱でも耐えられるが、将来大きなアプリに育つ場合、開発を妨げる原因になる。

設計が難しい利用の１つは、現在の機能のコードをただ書くのではなく、その後の変更も受け入れられる物を作らなければならないこと。
設計において、未来を考慮するとは、何が起こるか予測するのでなく、将来何かが起こると認め受け入れるための選択肢を設計者に残すこと。
設計の目的は後にでも設計できるようにすること。
その目標は変更コストの削減。

## 1.2 設計の道具

設計とは決められた１連のルールに従う行為ではない。
設計は枝分かれをする道を進む旅であり、分かれ道の決断で未来が左右される。

オブジェクト指向設計者は原則とパターンという道具を持つ。

設計原則
SOLIDとはオブジェクト指向設計でよく知られている５原則。
Single Responsibility 単一責任
Open-Closed オープンクローズド
Liskov Substitution リスコフの置換
Interface Segregation インターフェース分離
Dependency Inversion 依存性逆転
これらの原則は誰かがコードを書いている間に選んだ選択肢。
これらの良い設計のための原則は計測できる事実に基づいている。

デザインパターン
一般的に共通する問題に同じ名前をつけて同じ手法で解決し明確にする。
ただ間違って乱用すると混乱を招いてしまう。

## 1.3 設計の行為
設計原則とパターンが普及しても設計で大変なことはたくさんある。

設計が失敗する原因は設計が十分でないこと。
設計の初歩を知らなくても動くアプリケーションは作れるが、次第に変更できなくなる。

少し経験を積んだオブジェクト指向設計の手法を知ってはいるものの適用方法がわかっていないプログラマーの場合、良かれと思い設計しすぎてしまう。
そのため変更の要求に対して、それをやる設計はしていないため機能を追加できないと答える。

最終的に設計の行為と実装の行為が乖離した時に失敗する。
設計とは全身的な発見のプロセスであるから、適度な時間ごとに繰り返しフィードバックを行うべき。
なので、アジャイル開発はオブジェクト指向アプリケーション開発にうってつけ。
必要な調整が分かる前に設計をしてしまうと変更が難しくなってしまう。

アジャイルでは、顧客にはすぐに見せるのがベストという考えがある。
ソフトウェアは小さな追加の繰り返しで作っていくべき。
顧客が本当に求める物を生み出すための最も費用対効果の高い方法は、顧客と共同作業をすること。
アジャイル体験とはこの共同作業によって最初に想像した小野とは異なるソフトウェアが生み出されること。

アジャイルが正しいならば、前もって全体の詳細設計を作ることは意味のないこと。それが正しいことなどないから。
また、アプリケーションの完成時期は誰にもわからない。最終的にアプリが何をするのかを前もって知ることができないから。

詳細設計により、顧客とプログラマーは敵対する。
詳細設計を作ってもそれが正しいことはない。
仕様どうりに作っても顧客のニーズを満たすことができずに、変更を求められる。
プログラマーはスケジュールを守るために拒み、失敗の責任を追わせられないように注力する。

納期を過ぎればプログラマの責任、実際のニーズを満たしていなければ仕様が悪く顧客の責任。

アジャイルが有効である理由は、ソフトウェアが形になる前に確かさを手に入れることはできないと認めたから。

アジャイルが詳細設計を作るなというのは、設計をするなという意味ではない。
詳細設計は、全ての昨日の想定される未来の内部動作を全て特定し、完全に文書化すること。
オブジェクト指向設計は変更が簡単になるように、どんなコード構成にするかということ。

アジャイルは設計を禁止しているのではなく、シンプルで適応性があり柔軟性があるコードを実現できる設計を必要としている。

コードの行数が全体の品質について図る物差しにはならない。

メトリクスが有用な理由は、バイアスがかかっていないこと、ソフトウェアについて推測できる数字を出してくれること。

妥協をして設計することは、未来から時間を借りていることで技術的負債と呼ばれる。

設計者の目標は機能あたりに最も低い方法で書くこと。
自身のスキルと結果が出るまでの時間によって、どの程度設計するかを決断する。

設計の損益分岐点はプログラマによって異なる。
経験の浅い人が将来を予測した設計をしたところで報われることは永遠にない。
逆に熟練者なら午前中に書いたコードで午後のうちにコストを削減できるかもしれない。

## 1.4


